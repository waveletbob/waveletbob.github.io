---
layout: post
title: 数据结构基础
categories: 数据结构与算法
tags: 数据结构

---

## 数据结构基础 ##

### 数据结构简介 ###

@（数据集合）[数据存储|数据关系|数据运算]

> 是由相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。具体指同一类数据元素中，各元素之间的相互关系，包括三个组成成分，数据的**逻辑结构**，数据的**存储结构**和数据**运算结构**。

---------
线性结构
非线性结构

顺序存储
链式存储
索引存储
哈希（散列）


时间复杂度
空间复杂度

### 线性表 ###

 - 数组
 - 链表
 - 队列
 - 栈
 - 广义表
 - 应用

### 树 ###

- 非线性结构、树概念、二叉树
- 平衡树、AVL树、线索二叉树
- B树相关与数据库索引

### 图 ###

- 图的概念与存储
- 图的遍历
- 最小生成树（MST）、Prim算法、Kruskal算法
- 单源最短路径与Dijkstra算法
- 用遗传算法近似求解TSP问题

### 查找 ###

- **线性表**
	- 顺序查找
	- 折半查找（有序）
	- 分块查找
- **树**
	- 二叉排序树*BST* 
	- 平衡二叉树排序树*AVL*
		- 插入删除不平衡后调整：LL、RR、LR、RL
		- 结构定义
		- 插入
		- 查找
		- 删除
	- B+树、B-树（B树）、B*树、R树
	- 红黑树*RBT*
- **哈希查找**

两个问题要解决：

- 哈希函数构造：散列表基于数组存储，快速插入和查找很快O(1),缺点是存储容量固定，当数据密集或很多时需要扩容；
	- 直接定址法：Hash（key）=key或Hash（key）=a*key+b；
	- 数字分析法
	- 折叠法
	- 除留余数法Hash（key）=key%p
	- 随机数法
- 构造方法小结：
	- 计算散列地址所需的时间；
	- 关键字的长度
	- 散列表的长度
	- 关键字的分布情况
	- 记录查找的频率
- 解决冲突的方法有：开放地址法（线性探测、二次探测、再哈希）和链地址法

- **字符串**
KMP

时间复杂度为O（m+n），解决指针回溯的问题
Trie Tree

### 排序算法 ###


![这里写图片描述](http://img.blog.csdn.net/20170702103929603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQwNjc4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![这里写图片描述](http://my.csdn.net/uploads/201207/19/1342700879_2982.jpg)

![这里写图片描述](http://my.csdn.net/uploads/201207/21/1342856655_3698.jpg)

***注：对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法（快排、堆排、归并排序）。***

- 快速排序：
	时间复杂度：O（n*lgn）
	空间复杂度：O（n^2）
	最坏情况：O（n*lgn）
	不稳定
	以基准数（通常是第一个）为中心，将小于基准数与大于基准数的数分为左右两边划分。
![这里写图片描述](http://my.csdn.net/uploads/201207/20/1342782317_4426.jpg)
	平均性能最好，但如果是初始序列有序或基本有序时与冒泡无异，为改进之，用三者取中的方法选取基准，将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录
- 2、堆排序
		直接选择的改进方法，**树形**选择排序。

		步骤：建立初始堆（按树形结构存储）
			输出堆顶元素后调整剩下的元素继续构建新堆
![这里写图片描述](http://my.csdn.net/uploads/201207/18/1342596333_5296.jpg)
- 3、归并排序

![这里写图片描述](http://my.csdn.net/uploads/201207/21/1342842633_6751.jpg)

- 4、直接插入
- 5、简单选择排序
- 6、冒泡排序
- 7、希尔排序
- 8、基数排序
- 9、计数排序
- 10、桶排序
	
> 桶排序假设输入数据服从均匀分布，平均情况下它的时间复杂度为O（n）。与计数排序类似，因为对输入数据作了某种假设，桶排序的速度也很快。

> 桶排序将输入元素按照一定的区间划分为若干个桶，因为假设了输入的数据在总的区间范围内是均匀分布的，因此一般不会出现很多个元素落在同一个桶中的情况。我们可以先对每个桶中的元素排序，而后按照桶的序号，依次把各个桶中的元素列出来即可。

> 在进行桶排序时，我们需要一个辅助数组来存放每个桶，而每个桶中的元素最好用链表串起来，这样操作起来比较方便。一个很普遍的展示图例如下：

![](http://img.blog.csdn.net/20140304220631109)

常用于海量数据排序。

    