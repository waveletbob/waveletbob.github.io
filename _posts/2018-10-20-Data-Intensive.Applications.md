---
layout: post
title: Designing Data-Intensive Applications
categories: 数据科学
tags: 数据架构

---

### 1）可靠、可扩展、可维护的数据系统 ###


### 2）数据模型与查询语言 ###

### 3）数据存储与检索 ###

- K-V数据库
- 索引
	- 哈希索引
 SSTable（Cassandra，HBase，LevelDB，Bitcask等。Lucene的全文搜索的使用Elasticsearch和Solr索引引擎）
	- B树索引（在关系型数据库（如：MySQL，Oracle）与非关系型数据库（如：MongoDB）之中都大量应用）

### 4）OLTP与OLAP ###

- 比较
	- 数据量
	- 容忍延迟度
	- 最新数据/历史数据
- 数据仓库（OLAP）
- 面向列存储(OLAP)
	- 列存储
	- 位图编码压缩（列压缩）
	- 列排序
- 聚合：物化视图

### 5）序列化（编码） ###

- 主流编码
	- Apache Avro
	- Facebook Thrift
	- Google Protocolbuf

- 序列化（编码至内存字节序列）与反序列化（解码）
- 非二进制编码格式
	- 特定的语言格式
	- JSON、XML与CSV
- 二进制的编码格式
	- MessagPack
	- Thrift（Binary、Compact）
	- ProtocolBuf
	- Avro（Hadoop中Thrift的替代方案）
- 模式演化升级 

### 6）副本机制与副本同步 ###

- 副本

首先，如果副本的数据不随时间变化，那么副本的管理是比较简单的：只需要将数据复制到每个节点一次，就OK了。副本管理真正的困难在于对副本数据的修改，这会涉及到很多琐碎的问题。其次，副本复制时要考虑许多权衡，使用同步还是异步复制，以及如何处理失效的副本？接下来我们来一一探讨这个问题。

- Leader-Follower机制
保持一致性，PostgreSQL，MySQL，Oracle Data Guard 和SQL Server。同时许多非关系型数据库与分布式消息队列也采用这样的机制，包括MongoDB，Rethinkd，Kafka，RabbitMQ
	- 同步与异步复制   
	- 添加新的follower
	- 节点故障
- 日志复制
- 复制延迟

### 7)读写一致性 ###

- 客户端困扰
第一次查询到数据（副本一），第二次却没查到（尚未同步到数据的副本2）
- 多数据中心leader机制
- 写冲突（多leader机制）
- 多leader的复制拓扑

### 8）P2P结构与Quorum ###

- 无leader机制
	- 多副本读写
	- 副本修复
- Quorum机制

每次读写达到指定人数，假设有n个副本，每次写操作必须由w个节点确认为成功，每个读操作读取r个节点。（在上文的例子中，n＝3，w＝2，r＝2）。只要w + r > n，如果读和写操作的总次数大于n，那么读和写操作必然至少有一个副本是相同的，也就是读操作必然可以读到最新写操作的数据

	- 高可用与Hinted handoff
	- 写冲突

### 9）数据分区 ###

- 分区与副本
- 分区策略
	- 范围分区
	- 哈希分区
		- 缓解热点（前缀随机数，追踪热键）
- 分区与二级索引
	- 基于分区的索引
	- 基于全局的索引
- 分区平衡
	- 海量分区
	- 动态分区
- 请求路由
	- 1.允许客户端与任何节点联系。如果该节点恰好拥有请求所应用的分区，则它可以直接处理请求；否则，它将请求转发到适当的节点，接收应答，并将应答传递给客户端。
	- 2.将客户端的所有请求首先发送到路由层，这将决定应处理每个请求并相应转发它的节点。
	- 3.要求客户端知道分区和分配给节点的分区。在这种情况下，客户机可以直接连接到适当的节点，而不需要任何中介。

	- 协调服务Zookeeper 

### 10）事务与隔离级别 ###

- ACID
- 隔离级别
	- Read Commited（防止脏读、脏写，行级锁）
	- Read Repeatable（实现可重复读=>快照隔离MVCC）
	- Serializability（并发写解决一致性问题）
		- 两阶段锁（2PL），共享锁与独占锁共同解决一切并发问题，但是并发性能差
		- 序列化的快照隔离（SSI），可串行化快照中一个事务不需要阻塞等待其他事务的锁

### 11）分布式系统的难题 ###  

- 故障与部分失效
	> ​	单个计算机上的软件没有根本性的不可靠原因：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统故障（例如，内核恐慌，“蓝屏死机”，启动失败）。装有良好软件的个人计算机通常要么功能完好，要么完全失效，而不是介于两者之间。

	> 在分布式系统中，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式被破坏。这被称为部分失效（partial failure）。难点在于部分失效是不确定性的（nonderterministic）：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败。正如我们将要看到的，你甚至不知道是否成功了，因为消息通过网络传播的时间也是不确定的！这种不确定性和部分失效的可能性，使得分布式系统难以工作

	- 云计算与超级计算机

- 不可靠的网络
	- 真实世界的网络故障
	- 检测故障
	- 超时与无穷的延迟
		- 网络堵塞和排队
	- 同步网络与异步网络
- 不可靠的时钟
- 知识、真想与谎言
	- 大多数决定真理
	- 拜占庭故障
	- 系统模型与现实
		- 系统时间模型
			- 同步模型
			- 部分同步模型
			- 异步模型
		- 节点系统模型
			- 崩溃-停止故障
			- 崩溃-恢复故障
			- 拜占庭（任意）故障
		- 算法正确性
			- 唯一性
			- 单调序列
			- 可用性
		- 安全性（没有坏事出现）与活性（结果是好的）

### 12）一致性与共识 ### 



----------
首先在数据库的概念中存在事务的四个隔离级别ACID，其中的一致性一般指内部数据的一致性，通常在一个节点上，平时高并发多线程所要保持的一致性锁便是指这个，而在分布式数据系统中有CAP的一个概念，其中的一致性指的是外部的数据一致性，一般指分布式系统中各个副本上的数据保持一致，而为了保持外部系统数据的一致性所使用的锁也就是分布式锁的概念了。

----------

### 13）批处理 ###

- Unix工具批处理
- MapReduce
- 其他批处理

### 14）流处理 ###

### 15）数据系统的未来 ###


 